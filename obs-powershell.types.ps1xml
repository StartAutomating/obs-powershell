<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 1.9.9: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>OBS.GetSceneItemList.Response</Name>
    <Members>
      <ScriptMethod>
        <Name>Animate</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Animates scene items
.DESCRIPTION
    Animates the motion of scene items within a frame.
.EXAMPLE
    $stars = Add-OBSBrowserSource -URI https://pssvg.start-automating.com/Examples/Stars.svg
    $stars.Animate(@{
        scale = 0.1        
    },"00:00:01")
#&gt;
param(
)

$nextTimeSpan = [timespan]0

$keyNames = 'positionX', 'positionY', 'scaleX','scaleY', 'cropBottom', 'cropLeft', 'cropRight', 'cropTop', 'rotation'
$keyAliases = [Ordered]@{'Rotate'='rotation'}
$duplicatedKeyAliases = [Ordered]@{
    'position' = 'positionX', 'positionY'
    'scale' = 'scaleX', 'scaleY'
    'crop' = 'cropBottom', 'cropLeft', 'cropRight', 'cropTop'
}
foreach ($position in 'X','Y') {
    $keyAliases[$position] = "position$position"
}
foreach ($cropType in 'Bottom','Left', 'Right', 'Top') {
    $keyAliases[$cropType] = "crop$cropType"
}
   
$allSteps = @()


$originalTransform = $this | Get-OBSSceneItemTransform
$lastFrom = 
    if ($originalTransform -is [Collections.IDictionary]) {
        [Ordered]@{} + $from
    } else {
        $newFrom = [Ordered]@{}
        foreach ($property in $originalTransform.psobject.properties) {
            $newFrom[$property.Name] = $property.Value
        }
        $newFrom
    }

$totalTimeSpan = [timespan]0

# We want to walk over every argument and turn them into a series of animations

$IsFirstArg = $true
$PassThru   = $false

$AllArgs = @($args)

:NextArgument for ($argIndex = 0 ; $argIndex -lt $allArgs.Length; $argIndex++) {
    $arg = $allArgs[$argIndex]
    # If the arg is a timespan, we want to track this
    if ($arg -as [timespan]) {
        $nextTimeSpan = $arg -as [timespan]
    } elseif ($arg -is [double] -or $arg -is [int]) {
        $nextTimeSpan = [timespan]::fromSeconds($arg)
    }
    elseif ($arg -is [bool]) {
        if ($arg) {
            $PassThru = $true
        }
    }
    else {
        $currentTo = 
            if ($arg -isnot [Collections.IDictionary]) {
                $newTo = [Ordered]@{}
                foreach ($property in $arg.psobject.properties) {
                    $newTo[$property.Name] = $property.Value
                }
                $newTo
            } else {
                [Ordered]@{} + $arg
            }

        $badKey = 
            @(foreach ($k in @($currentTo.Keys)) {
                if ($k -notin $keyNames) {
                    if ($keyAliases[$k]) {
                        $currentTo[$keyAliases[$k]] = $currentTo[$k]
                        $currentTo.Remove($k)
                    } 
                    elseif ($duplicatedKeyAliases[$k]) {
                        foreach ($duplicateKey in $duplicatedKeyAliases[$k]) {
                            $currentTo[$duplicateKey] = $currentTo[$k]
                        }
                        
                        $currentTo.Remove($k)
                    }
                    else {
                        $k
                    }
                }
            })
        
        if ($badKey) {
            throw "Cannot animate '$($badKey -join "','")' : Can only animate $($keyNames -join ',')"
        }

        if (-not $nextTimeSpan.TotalMilliseconds -and 
            ($argIndex -lt ($AllArgs.Length - 1)) -and 
            $AllArgs[$argIndex + 1] -as [timespan]
        ) {
            $nextTimeSpan = $AllArgs[$argIndex + 1] -as [timespan]
            $argIndex++
        }

        if ($lastFrom -and $nextTimeSpan) {
            $StepCount = [Math]::Ceiling($NextTimeSpan.TotalMilliseconds / ([timespan]::fromSeconds(1/30).TotalMilliseconds)) * 2            
            if (-not $StepCount) {
                $allSteps += $this | Set-OBSSceneItemTransform -SceneItemTransform $currentTo -PassThru
                $newLastFrom = [Ordered]@{} + $currentTo
                foreach ($kv in $lastFrom.GetEnumerator()) {
                    if ($currentTo.Contains($kv.Key)) { continue }
                    $newLastFrom[$kv.Key] = $kv.Value
                }
                $lastFrom = $newLastFrom # May need to join this with the remaining properties in from

                $totalTimeSpan += $nextTimeSpan
                $nextTimeSpan = [timespan]0
                continue NextArgument
            }

            $stepMilliseconds  = $nextTimeSpan.TotalMilliseconds / $StepCount

            
            # Compare the two sets of keys to determine the base data object
            $BaseObject = [Ordered]@{}
            foreach ($key in $currentTo.Keys) {
                if (-not $BaseObject[$key]) {
                    $BaseObject[$key] = 
                        if ($null -ne $lastFrom[$key]) {
                            $lastFrom[$key]
                        } else {
                            $currentTo[$key]
                        }
                }
            }                    

            # Determine the animation change per step.
            $eachStepValue = [Ordered]@{}
            foreach ($key in $baseObject.Keys) {
                $distance = try { $currentTo[$key] - $baseObject[$key] } catch { $null }
                if ($null -ne $distance) {
                    $eachStepValue[$key] = [float]$distance / $StepCount
                }
            }

            $allSteps += 
                foreach ($stepNumber in 1..($stepCount)) {
                    $stepObject = [Ordered]@{}
                    foreach ($key in $BaseObject.Keys) {
                        $stepObject[$key] = $BaseObject[$key] + ($eachStepValue[$key] * $stepNumber)
                    }
                    $this | Set-OBSSceneItemTransform -SceneItemTransform $stepObject -PassThru
                    Send-OBSSleep -SleepMillis $stepMilliseconds -PassThru
                }

        } else {
            $allSteps += 
                $this | Set-OBSSceneItemTransform -SceneItemTransform $currentTo -PassThru
        }
        $newLastFrom = [Ordered]@{} + $currentTo
        foreach ($kv in $lastFrom.GetEnumerator()) {
            if ($currentTo.Contains($kv.Key)) { continue }
            $newLastFrom[$kv.Key] = $kv.Value
        }
        $lastFrom = $newLastFrom # May need to join this with the remaining properties in from

        $totalTimeSpan += $nextTimeSpan
        $nextTimeSpan = [timespan]0
    }

    $IsFirstArg = $false
}

if ($allSteps) {
    Write-Debug "Sending $($allSteps.Count) messages to OBS"
    # If any boolean true was in the arguments, we're passing thru
    if ($PassThru) {
        $allSteps
    } else {
        # Send all of the steps to OBS.
        $allSteps | Send-OBS
    }
    
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Blend</Name>
        <Script>
                        param([string]$BlendMode)

if ($blendMode -cnotmatch '^OBS_BLEND_') {
    $blendMode = "OBS_BLEND_$($blendMode.ToUpper())"
}
$this |
    Set-OBSSceneItemBlendMode -SceneItemBlendMode $blendMode

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Crop</Name>
        <Script>
                        $cropTable = [Ordered]@{
    cropBottom = 0
    cropLeft   = 0
    cropRight  = 0
    cropTop    = 0
}

$MatchingKey = [Regex]::new("(?&gt;$(
    @($cropTable.Keys -join '|'
    '|'
    $cropTable.Keys -replace '^crop' -join '|') -join ''
))", 'IgnoreCase')


$currentKey = ''
foreach ($arg in $args) {
    if ($arg -is [Collections.IDictionary]) {
        foreach ($keyValue in $arg.GetEnumerator()) {
            if ($keyValue.Key -match $MatchingKey) {
                $cropTable[$matches.0 -replace '^crop' -replace '^', 'crop'] = $keyValue.Value
            }        
        }
    }
    if ($arg -is [string] -and $arg -match $MatchingKey) {
        $currentKey = $matches.0 -replace '^crop' -replace '^', 'crop'
    }
    if ($arg -is [int] -and $currentKey) {
        $cropTable[$currentKey] = $arg
        $currentKey = ''
    }
}

$this | Set-OBSSceneItemTransform -SceneItemTransform $cropTable

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Delete</Name>
        <Script>
                        $this.Remove()
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Disable</Name>
        <Script>
                        $this | Set-OBSSceneItemEnabled -sceneItemEnabled:$false

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Enable</Name>
        <Script>
                        $this | Set-OBSSceneItemEnabled -sceneItemEnabled

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>FitToScreen</Name>
        <Script>
                        $videoSettings = Get-OBSVideoSettings

$thisTransform = $this | Get-OBSSceneItemTransform

$sceneItemTransform = ([Ordered]@{
    alignment = 0
    scaleX    = ([double]$videoSettings.outputWidth / $thisTransform.sourceWidth )
    positionX = [int]($videoSettings.outputWidth / 2)
    positionY = [int]($videoSettings.outputHeight / 2)
    scaleY    = ([double]$videoSettings.outputHeight / $thisTransform.sourceHeight )
})

$this | Set-OBSSceneItemTransform -SceneItemTransform $sceneItemTransform
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Lock</Name>
        <Script>
                        $this | Set-OBSSceneItemLocked -sceneItemLocked
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Remove</Name>
        <Script>
                        $this | Remove-OBSSceneItem
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Rotate</Name>
        <Script>
                        param(
[Alias('Degrees', 'Rotation')]
[double]
$Degree
)

$this | Set-OBSSceneItemTransform -SceneItemTransform @{
    rotation = $Degree
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Scale</Name>
        <Script>
                        param(
[double[]]
$ScaleX = 1,

[double[]]
$ScaleY = 1,

# The timespan the animation will take
[TimeSpan]
$TimeSpan = [timespan]::fromSeconds(1)
)

if ($scaleX.Length -eq 1 -and $scaleY.Length -eq 1) {
    $this | Set-OBSSceneItemTransform -SceneItemTransform @{
        scaleX = $ScaleX[0]
        scaleY = $scaleY[0]
    }
    return
}

$thisTransform = $this | Get-OBSSceneItemTransform 

$fromValue = [Ordered]@{
    scaleX = $thisTransform.scaleX
    scaleY = $thisTransform.scaleY
}

$durationPerStep = [TimeSpan]::FromMilliseconds($TimeSpan.TotalMilliseconds / $ScaleX.Length)

for ($stepNumber = 0; $stepNumber -lt $ScaleX.Length; $stepNumber++) {
    $toValue = [Ordered]@{
        scaleX = $ScaleX[$stepNumber]
        scaleY = $ScaleY[$stepNumber]
    }
    $this.Animate($fromValue, $toValue, $durationPerStep)
    $fromValue = $toValue
}


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Unlock</Name>
        <Script>
                        $this | Set-OBSSceneItemLocked -sceneItemLocked:$false

                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>BlendMode</Name>
        <GetScriptBlock>
                        $this.sceneItemBlendMode -replace '^OBS_BLEND_'

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Enabled</Name>
        <GetScriptBlock>
                        return $this.sceneItemEnabled

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ImageHeight</Name>
        <GetScriptBlock>
                        $this.sceneItemTransform.sourceHeight

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ImageWidth</Name>
        <GetScriptBlock>
                        $this.sceneItemTransform.sourceWidth

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Layer</Name>
        <GetScriptBlock>
                        return $this.sceneItemIndex

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>OBS.Input.Color.Source.V3</Name>
    <Members>
      <ScriptMethod>
        <Name>SetColor</Name>
        <Script>
                        param(
[ValidatePattern('\#(?&gt;[0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})')]
[string]
$Color
)

$hexChar = [Regex]::new('[0-9a-f]')
$hexColors = @($hexChar.Matches($Color))

switch ($hexColors.Length) {
    8 {
        #full rgba
        $alpha = [byte]::Parse($hexColors[0..1] -join '', 'HexNumber')
        $red   = [byte]::Parse($hexColors[2..3] -join '', 'HexNumber')
        $green = [byte]::Parse($hexColors[4..5] -join '', 'HexNumber')
        $blue  = [byte]::Parse($hexColors[6..7] -join '', 'HexNumber')
    }
    6 {
        #rgb only, assume ff for alpha
        $alpha = 0xff
        $red   = [byte]::Parse($hexColors[0..1] -join '', 'HexNumber')
        $green = [byte]::Parse($hexColors[2..3] -join '', 'HexNumber')
        $blue  = [byte]::Parse($hexColors[4..5] -join '', 'HexNumber')
    }
    4 {
        #short rgba                
        $alpha = [byte]::Parse(($hexColors[0],$hexColors[0] -join ''), 'HexNumber')
        $red   = [byte]::Parse(($hexColors[1],$hexColors[1] -join ''), 'HexNumber')
        $green = [byte]::Parse(($hexColors[2],$hexColors[2] -join ''), 'HexNumber')
        $blue  = [byte]::Parse(($hexColors[3],$hexColors[3] -join ''), 'HexNumber')
    }
    3 {
        #short rgb, assume f for alpha
        $alpha = 0xff
        $red   = [byte]::Parse(($hexColors[0],$hexColors[0] -join ''), 'HexNumber')
        $green = [byte]::Parse(($hexColors[1],$hexColors[1] -join ''), 'HexNumber')
        $blue  = [byte]::Parse(($hexColors[2],$hexColors[2] -join ''), 'HexNumber')
    }
    0 {
        # No color provided, default to transparent black
        $alpha = 0
        $red   = 0
        $green = 0 
        $blue  = 0
    }
}

$hexColor = ("{0:x2}{1:x2}{2:x2}{3:x2}" -f $alpha, $blue, $green, $red)

$realColor = [uint32]::Parse($hexColor,'HexNumber')

$this | Set-OBSInputSettings -InputSettings ([Ordered]@{color=$realColor})




                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
</Types>
