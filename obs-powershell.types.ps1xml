<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 1.9.9: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>OBS.GetSceneItemList.Response</Name>
    <Members>
      <ScriptMethod>
        <Name>Animate</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Animates scene items
.DESCRIPTION
    Animates the motion of scene items within a frame.
.EXAMPLE
    $stars = Add-OBSBrowserSource -URI https://pssvg.start-automating.com/Examples/Stars.svg
    $stars.Animate(@{
        scale = 0.1        
    },"00:00:01")
#&gt;
param(
)

$nextTimeSpan = [timespan]0

$keyNames = 'positionX', 'positionY', 'scaleX','scaleY', 'cropBottom', 'cropLeft', 'cropRight', 'cropTop', 'rotation'
$keyAliases = [Ordered]@{'Rotate'='rotation'}
$duplicatedKeyAliases = [Ordered]@{
    'position' = 'positionX', 'positionY'
    'scale' = 'scaleX', 'scaleY'
    'crop' = 'cropBottom', 'cropLeft', 'cropRight', 'cropTop'
}
foreach ($position in 'X','Y') {
    $keyAliases[$position] = "position$position"
}
foreach ($cropType in 'Bottom','Left', 'Right', 'Top') {
    $keyAliases[$cropType] = "crop$cropType"
}
   
$allSteps = @()


$originalTransform = $this | Get-OBSSceneItemTransform
$lastFrom = 
    if ($originalTransform -is [Collections.IDictionary]) {
        [Ordered]@{} + $from
    } else {
        $newFrom = [Ordered]@{}
        foreach ($property in $originalTransform.psobject.properties) {
            $newFrom[$property.Name] = $property.Value
        }
        $newFrom
    }

$totalTimeSpan = [timespan]0

# We want to walk over every argument and turn them into a series of animations

$PassThru   = $false

$AllArgs = @($args)

$allSteps = @(
:NextArgument for ($argIndex = 0 ; $argIndex -lt $allArgs.Length; $argIndex++) {
    $arg = $allArgs[$argIndex]
    # If the arg is a timespan, we want to track this
    if ($arg -as [timespan]) {
        $nextTimeSpan = $arg -as [timespan]
    } elseif ($arg -is [double] -or $arg -is [int]) {
        $nextTimeSpan = [timespan]::fromSeconds($arg)
    }
    elseif ($arg -is [bool]) {
        if ($arg) {
            $PassThru = $true
        }
    }
    else {
        $currentTo = 
            if ($arg -isnot [Collections.IDictionary]) {
                $newTo = [Ordered]@{}
                foreach ($property in $arg.psobject.properties) {
                    $newTo[$property.Name] = $property.Value
                }
                $newTo
            } else {
                [Ordered]@{} + $arg
            }

        $badKey = 
            @(foreach ($k in @($currentTo.Keys)) {
                if ($k -notin $keyNames) {
                    if ($keyAliases[$k]) {
                        $currentTo[$keyAliases[$k]] = $currentTo[$k]
                        $currentTo.Remove($k)
                    } 
                    elseif ($duplicatedKeyAliases[$k]) {
                        foreach ($duplicateKey in $duplicatedKeyAliases[$k]) {
                            $currentTo[$duplicateKey] = $currentTo[$k]
                        }
                        
                        $currentTo.Remove($k)
                    }
                    else {
                        $k
                    }
                }
            })
        
        if ($badKey) {
            throw "Cannot animate '$($badKey -join "','")' : Can only animate $($keyNames -join ',')"
        }

        if (-not $nextTimeSpan.TotalMilliseconds -and 
            ($argIndex -lt ($AllArgs.Length - 1)) -and 
            $AllArgs[$argIndex + 1] -as [timespan]
        ) {
            $nextTimeSpan = $AllArgs[$argIndex + 1] -as [timespan]
            $argIndex++
        }

        if ($lastFrom -and $nextTimeSpan) {
            $StepCount = [Math]::Ceiling($NextTimeSpan.TotalMilliseconds / ([timespan]::fromSeconds(1/30).TotalMilliseconds)) * 2            
            if (-not $StepCount) {
                $this | Set-OBSSceneItemTransform -SceneItemTransform $currentTo -PassThru
                $newLastFrom = [Ordered]@{} + $currentTo
                foreach ($kv in $lastFrom.GetEnumerator()) {
                    if ($currentTo.Contains($kv.Key)) { continue }
                    $newLastFrom[$kv.Key] = $kv.Value
                }
                $lastFrom = $newLastFrom # May need to join this with the remaining properties in from

                $totalTimeSpan += $nextTimeSpan
                $nextTimeSpan = [timespan]0
                continue NextArgument
            }

            $stepMilliseconds  = $nextTimeSpan.TotalMilliseconds / $StepCount

            
            # Compare the two sets of keys to determine the base data object
            $BaseObject = [Ordered]@{}
            foreach ($key in $currentTo.Keys) {
                if (-not $BaseObject[$key]) {
                    $BaseObject[$key] = 
                        if ($null -ne $lastFrom[$key]) {
                            $lastFrom[$key]
                        } else {
                            $currentTo[$key]
                        }
                }
            }                    

            # Determine the animation change per step.
            $eachStepValue = [Ordered]@{}
            foreach ($key in $baseObject.Keys) {
                $distance = try { $currentTo[$key] - $baseObject[$key] } catch { $null }
                if ($null -ne $distance) {
                    $eachStepValue[$key] = [float]$distance / $StepCount
                }
            }

            
            foreach ($stepNumber in 1..($stepCount)) {
                $stepObject = [Ordered]@{}
                foreach ($key in $BaseObject.Keys) {
                    $stepObject[$key] = $BaseObject[$key] + ($eachStepValue[$key] * $stepNumber)
                }
                $this | Set-OBSSceneItemTransform -SceneItemTransform $stepObject -PassThru
                Send-OBSSleep -SleepMillis $stepMilliseconds -PassThru
            }

        } else {
            $this | Set-OBSSceneItemTransform -SceneItemTransform $currentTo -PassThru
        }
        $newLastFrom = [Ordered]@{} + $currentTo
        foreach ($kv in $lastFrom.GetEnumerator()) {
            if ($currentTo.Contains($kv.Key)) { continue }
            $newLastFrom[$kv.Key] = $kv.Value
        }
        $lastFrom = $newLastFrom # May need to join this with the remaining properties in from

        $totalTimeSpan += $nextTimeSpan
        $nextTimeSpan = [timespan]0
    }

    $IsFirstArg = $false
}
)

if ($allSteps) {
    Write-Debug "Sending $($allSteps.Count) messages to OBS"
    # If any boolean true was in the arguments, we're passing thru
    if ($PassThru) {
        $allSteps
    } else {
        # Send all of the steps to OBS.
        Send-OBS -MessageData $allSteps
    }
    
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Blend</Name>
        <Script>
                        param([string]$BlendMode)

if ($blendMode -cnotmatch '^OBS_BLEND_') {
    $blendMode = "OBS_BLEND_$($blendMode.ToUpper())"
}
$this |
    Set-OBSSceneItemBlendMode -SceneItemBlendMode $blendMode

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Crop</Name>
        <Script>
                        $cropTable = [Ordered]@{
    cropBottom = 0
    cropLeft   = 0
    cropRight  = 0
    cropTop    = 0
}

$MatchingKey = [Regex]::new("(?&gt;$(
    @($cropTable.Keys -join '|'
    '|'
    $cropTable.Keys -replace '^crop' -join '|') -join ''
))", 'IgnoreCase')


$currentKey = ''
foreach ($arg in $args) {
    if ($arg -is [Collections.IDictionary]) {
        foreach ($keyValue in $arg.GetEnumerator()) {
            if ($keyValue.Key -match $MatchingKey) {
                $cropTable[$matches.0 -replace '^crop' -replace '^', 'crop'] = $keyValue.Value
            }        
        }
    }
    if ($arg -is [string] -and $arg -match $MatchingKey) {
        $currentKey = $matches.0 -replace '^crop' -replace '^', 'crop'
    }
    if ($arg -is [int] -and $currentKey) {
        $cropTable[$currentKey] = $arg
        $currentKey = ''
    }
}

$this | Set-OBSSceneItemTransform -SceneItemTransform $cropTable

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Delete</Name>
        <Script>
                        $this.Remove()
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Disable</Name>
        <Script>
                        $this | Set-OBSSceneItemEnabled -sceneItemEnabled:$false

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Enable</Name>
        <Script>
                        $this | Set-OBSSceneItemEnabled -sceneItemEnabled

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>FitToScreen</Name>
        <Script>
                        $videoSettings = Get-OBSVideoSettings

$thisTransform = $this | Get-OBSSceneItemTransform

$sceneItemTransform = ([Ordered]@{
    alignment = 0
    scaleX    = ([double]$videoSettings.outputWidth / $thisTransform.sourceWidth )
    positionX = [int]($videoSettings.outputWidth / 2)
    positionY = [int]($videoSettings.outputHeight / 2)
    scaleY    = ([double]$videoSettings.outputHeight / $thisTransform.sourceHeight )
})

$this | Set-OBSSceneItemTransform -SceneItemTransform $sceneItemTransform
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Lock</Name>
        <Script>
                        $this | Set-OBSSceneItemLocked -sceneItemLocked
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Move</Name>
        <Script>
                        filter ToPosition {
    param(
    [switch]
    $Width,

    [switch]
    $Height
    )

    
    if ($_ -is [string] -and $_ -match '%$') {
        $_ = $_ -replace '%$' -as [double]
        if (-not $videoSettings) {
            $videoSettings = Get-OBSVideoSettings
        }
        if ($Width) {
            $_/100 * $videoSettings.baseWidth
        }
        if ($Height) {
            $_/100 * $videoSettings.baseHeight
        }
        
    }
    elseif ($_ -is [double] -or $_ -is [int]) {
        if ($_ -is [double] -and $_ -ge 0 -and $_ -le 1) {
            if (-not $videoSettings) {
                $videoSettings = Get-OBSVideoSettings
            }
            if ($Width) {
                $_ * $videoSettings.baseWidth
            }
            if ($Height) {
                $_ * $videoSettings.baseHeight
            }
            
        } else {
            [int]$_
        }
    }
}

$allArguments = @($args)
$animateArguments = @(
foreach ($arg in $allArguments) {    
    if (
        ($arg -is [string] -and $arg -match '\%$') -or 
        ($arg -is [double] -and $arg -ge 0 -and $arg -le 1)
    ) {        
        $positionTransform = @{
            positionX = $arg | . ToPosition -Width
            positionY = $arg | . ToPosition -Height
        }
        $positionTransform
    } elseif ($arg.X,$arg.Y, $arg.positionX, $arg.positionY -ne $null) {
        $scaleInfo = @{}
        
        
        if ($null -ne $arg.X) {
            $scaleInfo.positionX = $arg.X | . ToPosition -Width
        }
        elseif ($null -ne $arg.positionX) {
            $scaleInfo.positionX = $arg.positionX | . ToPosition -Width
        }

        if ($null -ne $arg.Y) {
            $scaleInfo.positionY = $arg.Y | . ToPosition -Height
        }
        elseif ($null -ne $arg.positionY) {
            $scaleInfo.positionY = $arg.positionY | . ToPosition -Height
        }
        
        $scaleInfo
    }    
    elseif ($arg -as [timespan]) {
        $arg
    } elseif ($arg -is [bool]) {
        $arg
    }
})

$this.Animate.Invoke($animateArguments)


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Remove</Name>
        <Script>
                        $this | Remove-OBSSceneItem
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Rotate</Name>
        <Script>
                        param()
$allArguments = @($args)

$animateArguments  = @(
    foreach ($argument in $allArguments) {
        if ($argument -is [double] -or $argument -is [int]) {
            @{
                rotation = $argument
            }
        } elseif ($argument -as [timespan]) {
            $argument
        } elseif ($argument -is [bool]) {
            $argument
        }
    }
)

$this.Animate.Invoke($animateArguments)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Scale</Name>
        <Script>
                        param()

filter ToScale {
    if ($_ -is [string] -and $_ -match '%$') {
        $_ = $_ -replace '%$' -as [double]
        $_/100
    }
    elseif ($_ -is [double] -or $_ -is [int]) {
        if ($_ -is [double] -and $_ -ge 0 -and $_ -le 1) {
            $_
        } else {
            [double]$_/100
        }
    }
}

$allArguments = @($args)
$animateArguments = @(
foreach ($arg in $allArguments) {    
    if ($arg -is [double] -or $arg -is [int] -or 
        ($arg -is [string] -and $arg -match '\%$')
    ) {
        $scale = $arg | numToScale
        @{scaleX=$scale;scaleY=$scale}        
    } elseif ($arg.X -or $arg.Y) {
        $scaleInfo = @{}
        if ($null -ne $arg.X) {
            $scaleInfo.scaleX = $arg.X | numToScale
        }
        if ($null -ne $arg.Y) {
            $scaleInfo.scaleY = $arg.Y | numToScale
        }
        $scaleInfo
    } elseif ($arg -as [timespan]) {
        $arg
    } elseif ($arg -is [bool]) {
        $arg
    }
})

$this.Animate.Invoke($animateArguments)

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Unlock</Name>
        <Script>
                        $this | Set-OBSSceneItemLocked -sceneItemLocked:$false

                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>BlendMode</Name>
        <GetScriptBlock>
                        $this.sceneItemBlendMode -replace '^OBS_BLEND_'

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Enabled</Name>
        <GetScriptBlock>
                        return $this.sceneItemEnabled

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ImageHeight</Name>
        <GetScriptBlock>
                        $this.sceneItemTransform.sourceHeight

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ImageWidth</Name>
        <GetScriptBlock>
                        $this.sceneItemTransform.sourceWidth

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Layer</Name>
        <GetScriptBlock>
                        return $this.sceneItemIndex

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>OBS.Input.Color.Source.V3</Name>
    <Members>
      <ScriptMethod>
        <Name>SetColor</Name>
        <Script>
                        param(
[ValidatePattern('\#(?&gt;[0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})')]
[string]
$Color
)

$hexChar = [Regex]::new('[0-9a-f]')
$hexColors = @($hexChar.Matches($Color))

switch ($hexColors.Length) {
    8 {
        #full rgba
        $alpha = [byte]::Parse($hexColors[0..1] -join '', 'HexNumber')
        $red   = [byte]::Parse($hexColors[2..3] -join '', 'HexNumber')
        $green = [byte]::Parse($hexColors[4..5] -join '', 'HexNumber')
        $blue  = [byte]::Parse($hexColors[6..7] -join '', 'HexNumber')
    }
    6 {
        #rgb only, assume ff for alpha
        $alpha = 0xff
        $red   = [byte]::Parse($hexColors[0..1] -join '', 'HexNumber')
        $green = [byte]::Parse($hexColors[2..3] -join '', 'HexNumber')
        $blue  = [byte]::Parse($hexColors[4..5] -join '', 'HexNumber')
    }
    4 {
        #short rgba                
        $alpha = [byte]::Parse(($hexColors[0],$hexColors[0] -join ''), 'HexNumber')
        $red   = [byte]::Parse(($hexColors[1],$hexColors[1] -join ''), 'HexNumber')
        $green = [byte]::Parse(($hexColors[2],$hexColors[2] -join ''), 'HexNumber')
        $blue  = [byte]::Parse(($hexColors[3],$hexColors[3] -join ''), 'HexNumber')
    }
    3 {
        #short rgb, assume f for alpha
        $alpha = 0xff
        $red   = [byte]::Parse(($hexColors[0],$hexColors[0] -join ''), 'HexNumber')
        $green = [byte]::Parse(($hexColors[1],$hexColors[1] -join ''), 'HexNumber')
        $blue  = [byte]::Parse(($hexColors[2],$hexColors[2] -join ''), 'HexNumber')
    }
    0 {
        # No color provided, default to transparent black
        $alpha = 0
        $red   = 0
        $green = 0 
        $blue  = 0
    }
}

$hexColor = ("{0:x2}{1:x2}{2:x2}{3:x2}" -f $alpha, $blue, $green, $red)

$realColor = [uint32]::Parse($hexColor,'HexNumber')

$this | Set-OBSInputSettings -InputSettings ([Ordered]@{color=$realColor})




                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
</Types>
